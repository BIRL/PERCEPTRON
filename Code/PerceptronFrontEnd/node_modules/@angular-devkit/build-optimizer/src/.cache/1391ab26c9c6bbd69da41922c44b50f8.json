{"remainingRequest":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\webpack-dev-server\\client\\index.js?http://0.0.0.0:0","dependencies":[{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\webpack-dev-server\\client\\index.js","mtime":1532940290633},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["'use strict';\r\n\r\n/* global __resourceQuery WorkerGlobalScope self */\r\n/* eslint prefer-destructuring: off */\r\n\r\nvar url = require('url');\r\nvar stripAnsi = require('strip-ansi');\r\nvar log = require('loglevel').getLogger('webpack-dev-server');\r\nvar socket = require('./socket');\r\nvar overlay = require('./overlay');\r\n\r\nfunction getCurrentScriptSource() {\r\n  // `document.currentScript` is the most accurate way to find the current script,\r\n  // but is not supported in all browsers.\r\n  if (document.currentScript) {\r\n    return document.currentScript.getAttribute('src');\r\n  }\r\n  // Fall back to getting all scripts in the document.\r\n  var scriptElements = document.scripts || [];\r\n  var currentScript = scriptElements[scriptElements.length - 1];\r\n  if (currentScript) {\r\n    return currentScript.getAttribute('src');\r\n  }\r\n  // Fail as there was no script to use.\r\n  throw new Error('[WDS] Failed to get current script source.');\r\n}\r\n\r\nvar urlParts = void 0;\r\nvar hotReload = true;\r\nif (typeof window !== 'undefined') {\r\n  var qs = window.location.search.toLowerCase();\r\n  hotReload = qs.indexOf('hotreload=false') === -1;\r\n}\r\nif (typeof __resourceQuery === 'string' && __resourceQuery) {\r\n  // If this bundle is inlined, use the resource query to get the correct url.\r\n  urlParts = url.parse(__resourceQuery.substr(1));\r\n} else {\r\n  // Else, get the url from the <script> this file was called with.\r\n  var scriptHost = getCurrentScriptSource();\r\n  // eslint-disable-next-line no-useless-escape\r\n  scriptHost = scriptHost.replace(/\\/[^\\/]+$/, '');\r\n  urlParts = url.parse(scriptHost || '/', false, true);\r\n}\r\n\r\nif (!urlParts.port || urlParts.port === '0') {\r\n  urlParts.port = self.location.port;\r\n}\r\n\r\nvar _hot = false;\r\nvar initial = true;\r\nvar currentHash = '';\r\nvar useWarningOverlay = false;\r\nvar useErrorOverlay = false;\r\nvar useProgress = false;\r\n\r\nvar INFO = 'info';\r\nvar WARNING = 'warning';\r\nvar ERROR = 'error';\r\nvar NONE = 'none';\r\n\r\n// Set the default log level\r\nlog.setDefaultLevel(INFO);\r\n\r\n// Send messages to the outside, so plugins can consume it.\r\nfunction sendMsg(type, data) {\r\n  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {\r\n    self.postMessage({\r\n      type: 'webpack' + type,\r\n      data: data\r\n    }, '*');\r\n  }\r\n}\r\n\r\nvar onSocketMsg = {\r\n  hot: function hot() {\r\n    _hot = true;\r\n    log.info('[WDS] Hot Module Replacement enabled.');\r\n  },\r\n  invalid: function invalid() {\r\n    log.info('[WDS] App updated. Recompiling...');\r\n    // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\r\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\r\n    sendMsg('Invalid');\r\n  },\r\n  hash: function hash(_hash) {\r\n    currentHash = _hash;\r\n  },\r\n\r\n  'still-ok': function stillOk() {\r\n    log.info('[WDS] Nothing changed.');\r\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\r\n    sendMsg('StillOk');\r\n  },\r\n  'log-level': function logLevel(level) {\r\n    var hotCtx = require.context('webpack/hot', false, /^\\.\\/log$/);\r\n    if (hotCtx.keys().indexOf('./log') !== -1) {\r\n      hotCtx('./log').setLogLevel(level);\r\n    }\r\n    switch (level) {\r\n      case INFO:\r\n      case ERROR:\r\n        log.setLevel(level);\r\n        break;\r\n      case WARNING:\r\n        // loglevel's warning name is different from webpack's\r\n        log.setLevel('warn');\r\n        break;\r\n      case NONE:\r\n        log.disableAll();\r\n        break;\r\n      default:\r\n        log.error('[WDS] Unknown clientLogLevel \\'' + level + '\\'');\r\n    }\r\n  },\r\n  overlay: function overlay(value) {\r\n    if (typeof document !== 'undefined') {\r\n      if (typeof value === 'boolean') {\r\n        useWarningOverlay = false;\r\n        useErrorOverlay = value;\r\n      } else if (value) {\r\n        useWarningOverlay = value.warnings;\r\n        useErrorOverlay = value.errors;\r\n      }\r\n    }\r\n  },\r\n  progress: function progress(_progress) {\r\n    if (typeof document !== 'undefined') {\r\n      useProgress = _progress;\r\n    }\r\n  },\r\n\r\n  'progress-update': function progressUpdate(data) {\r\n    if (useProgress) log.info('[WDS] ' + data.percent + '% - ' + data.msg + '.');\r\n  },\r\n  ok: function ok() {\r\n    sendMsg('Ok');\r\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\r\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\r\n    reloadApp();\r\n  },\r\n\r\n  'content-changed': function contentChanged() {\r\n    log.info('[WDS] Content base changed. Reloading...');\r\n    self.location.reload();\r\n  },\r\n  warnings: function warnings(_warnings) {\r\n    log.warn('[WDS] Warnings while compiling.');\r\n    var strippedWarnings = _warnings.map(function (warning) {\r\n      return stripAnsi(warning);\r\n    });\r\n    sendMsg('Warnings', strippedWarnings);\r\n    for (var i = 0; i < strippedWarnings.length; i++) {\r\n      log.warn(strippedWarnings[i]);\r\n    }\r\n    if (useWarningOverlay) overlay.showMessage(_warnings);\r\n\r\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\r\n    reloadApp();\r\n  },\r\n  errors: function errors(_errors) {\r\n    log.error('[WDS] Errors while compiling. Reload prevented.');\r\n    var strippedErrors = _errors.map(function (error) {\r\n      return stripAnsi(error);\r\n    });\r\n    sendMsg('Errors', strippedErrors);\r\n    for (var i = 0; i < strippedErrors.length; i++) {\r\n      log.error(strippedErrors[i]);\r\n    }\r\n    if (useErrorOverlay) overlay.showMessage(_errors);\r\n    initial = false;\r\n  },\r\n  error: function error(_error) {\r\n    log.error(_error);\r\n  },\r\n  close: function close() {\r\n    log.error('[WDS] Disconnected!');\r\n    sendMsg('Close');\r\n  }\r\n};\r\n\r\nvar hostname = urlParts.hostname;\r\nvar protocol = urlParts.protocol;\r\n\r\n// check ipv4 and ipv6 `all hostname`\r\nif (hostname === '0.0.0.0' || hostname === '::') {\r\n  // why do we need this check?\r\n  // hostname n/a for file protocol (example, when using electron, ionic)\r\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\r\n  // eslint-disable-next-line no-bitwise\r\n  if (self.location.hostname && !!~self.location.protocol.indexOf('http')) {\r\n    hostname = self.location.hostname;\r\n  }\r\n}\r\n\r\n// `hostname` can be empty when the script path is relative. In that case, specifying\r\n// a protocol would result in an invalid URL.\r\n// When https is used in the app, secure websockets are always necessary\r\n// because the browser doesn't accept non-secure websockets.\r\nif (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {\r\n  protocol = self.location.protocol;\r\n}\r\n\r\nvar socketUrl = url.format({\r\n  protocol: protocol,\r\n  auth: urlParts.auth,\r\n  hostname: hostname,\r\n  port: urlParts.port,\r\n  pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path\r\n});\r\n\r\nsocket(socketUrl, onSocketMsg);\r\n\r\nvar isUnloading = false;\r\nself.addEventListener('beforeunload', function () {\r\n  isUnloading = true;\r\n});\r\n\r\nfunction reloadApp() {\r\n  if (isUnloading || !hotReload) {\r\n    return;\r\n  }\r\n  if (_hot) {\r\n    log.info('[WDS] App hot update...');\r\n    // eslint-disable-next-line global-require\r\n    var hotEmitter = require('webpack/hot/emitter');\r\n    hotEmitter.emit('webpackHotUpdate', currentHash);\r\n    if (typeof self !== 'undefined' && self.window) {\r\n      // broadcast update to window\r\n      self.postMessage('webpackHotUpdate' + currentHash, '*');\r\n    }\r\n  } else {\r\n    var rootWindow = self;\r\n    // use parent window for reload (in case we're in an iframe with no valid src)\r\n    var intervalId = self.setInterval(function () {\r\n      if (rootWindow.location.protocol !== 'about:') {\r\n        // reload immediately if protocol is valid\r\n        applyReload(rootWindow, intervalId);\r\n      } else {\r\n        rootWindow = rootWindow.parent;\r\n        if (rootWindow.parent === rootWindow) {\r\n          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\r\n          applyReload(rootWindow, intervalId);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  function applyReload(rootWindow, intervalId) {\r\n    clearInterval(intervalId);\r\n    log.info('[WDS] App updated. Reloading...');\r\n    rootWindow.location.reload();\r\n  }\r\n}",null]}