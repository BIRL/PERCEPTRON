{"remainingRequest":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\groupBy.js","dependencies":[{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\groupBy.js","mtime":1532940287390},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { Observable } from '../Observable';\r\nimport { Subject } from '../Subject';\r\nimport { Map } from '../util/Map';\r\nimport { FastMap } from '../util/FastMap';\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Groups the items emitted by an Observable according to a specified criterion,\r\n * and emits these grouped items as `GroupedObservables`, one\r\n * {@link GroupedObservable} per group.\r\n *\r\n * <img src=\"./img/groupBy.png\" width=\"100%\">\r\n *\r\n * @example <caption>Group objects by id and return as array</caption>\r\n * Observable.of<Obj>({id: 1, name: 'aze1'},\r\n *                    {id: 2, name: 'sf2'},\r\n *                    {id: 2, name: 'dg2'},\r\n *                    {id: 1, name: 'erg1'},\r\n *                    {id: 1, name: 'df1'},\r\n *                    {id: 2, name: 'sfqfb2'},\r\n *                    {id: 3, name: 'qfs3'},\r\n *                    {id: 2, name: 'qsgqsfg2'}\r\n *     )\r\n *     .groupBy(p => p.id)\r\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\r\n *     .subscribe(p => console.log(p));\r\n *\r\n * // displays:\r\n * // [ { id: 1, name: 'aze1' },\r\n * //   { id: 1, name: 'erg1' },\r\n * //   { id: 1, name: 'df1' } ]\r\n * //\r\n * // [ { id: 2, name: 'sf2' },\r\n * //   { id: 2, name: 'dg2' },\r\n * //   { id: 2, name: 'sfqfb2' },\r\n * //   { id: 2, name: 'qsgqsfg2' } ]\r\n * //\r\n * // [ { id: 3, name: 'qfs3' } ]\r\n *\r\n * @example <caption>Pivot data on the id field</caption>\r\n * Observable.of<Obj>({id: 1, name: 'aze1'},\r\n *                    {id: 2, name: 'sf2'},\r\n *                    {id: 2, name: 'dg2'},\r\n *                    {id: 1, name: 'erg1'},\r\n *                    {id: 1, name: 'df1'},\r\n *                    {id: 2, name: 'sfqfb2'},\r\n *                    {id: 3, name: 'qfs1'},\r\n *                    {id: 2, name: 'qsgqsfg2'}\r\n *                   )\r\n *     .groupBy(p => p.id, p => p.name)\r\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\r\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\r\n *     .subscribe(p => console.log(p));\r\n *\r\n * // displays:\r\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\r\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\r\n * // { id: 3, values: [ 'qfs1' ] }\r\n *\r\n * @param {function(value: T): K} keySelector A function that extracts the key\r\n * for each item.\r\n * @param {function(value: T): R} [elementSelector] A function that extracts the\r\n * return element for each item.\r\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\r\n * A function that returns an Observable to determine how long each group should\r\n * exist.\r\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\r\n * GroupedObservables, each of which corresponds to a unique key value and each\r\n * of which emits those items from the source Observable that share that key\r\n * value.\r\n * @method groupBy\r\n * @owner Observable\r\n */\r\nexport function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\r\n    return function (source) {\r\n        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\r\n    };\r\n}\r\nvar GroupByOperator = /*@__PURE__*/ (function () {\r\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\r\n        this.keySelector = keySelector;\r\n        this.elementSelector = elementSelector;\r\n        this.durationSelector = durationSelector;\r\n        this.subjectSelector = subjectSelector;\r\n    }\r\n    GroupByOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\r\n    };\r\n    return GroupByOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar GroupBySubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(GroupBySubscriber, _super);\r\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\r\n        _super.call(this, destination);\r\n        this.keySelector = keySelector;\r\n        this.elementSelector = elementSelector;\r\n        this.durationSelector = durationSelector;\r\n        this.subjectSelector = subjectSelector;\r\n        this.groups = null;\r\n        this.attemptedToUnsubscribe = false;\r\n        this.count = 0;\r\n    }\r\n    GroupBySubscriber.prototype._next = function (value) {\r\n        var key;\r\n        try {\r\n            key = this.keySelector(value);\r\n        }\r\n        catch (err) {\r\n            this.error(err);\r\n            return;\r\n        }\r\n        this._group(value, key);\r\n    };\r\n    GroupBySubscriber.prototype._group = function (value, key) {\r\n        var groups = this.groups;\r\n        if (!groups) {\r\n            groups = this.groups = typeof key === 'string' ? new FastMap() : new Map();\r\n        }\r\n        var group = groups.get(key);\r\n        var element;\r\n        if (this.elementSelector) {\r\n            try {\r\n                element = this.elementSelector(value);\r\n            }\r\n            catch (err) {\r\n                this.error(err);\r\n            }\r\n        }\r\n        else {\r\n            element = value;\r\n        }\r\n        if (!group) {\r\n            group = this.subjectSelector ? this.subjectSelector() : new Subject();\r\n            groups.set(key, group);\r\n            var groupedObservable = new GroupedObservable(key, group, this);\r\n            this.destination.next(groupedObservable);\r\n            if (this.durationSelector) {\r\n                var duration = void 0;\r\n                try {\r\n                    duration = this.durationSelector(new GroupedObservable(key, group));\r\n                }\r\n                catch (err) {\r\n                    this.error(err);\r\n                    return;\r\n                }\r\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\r\n            }\r\n        }\r\n        if (!group.closed) {\r\n            group.next(element);\r\n        }\r\n    };\r\n    GroupBySubscriber.prototype._error = function (err) {\r\n        var groups = this.groups;\r\n        if (groups) {\r\n            groups.forEach(function (group, key) {\r\n                group.error(err);\r\n            });\r\n            groups.clear();\r\n        }\r\n        this.destination.error(err);\r\n    };\r\n    GroupBySubscriber.prototype._complete = function () {\r\n        var groups = this.groups;\r\n        if (groups) {\r\n            groups.forEach(function (group, key) {\r\n                group.complete();\r\n            });\r\n            groups.clear();\r\n        }\r\n        this.destination.complete();\r\n    };\r\n    GroupBySubscriber.prototype.removeGroup = function (key) {\r\n        this.groups.delete(key);\r\n    };\r\n    GroupBySubscriber.prototype.unsubscribe = function () {\r\n        if (!this.closed) {\r\n            this.attemptedToUnsubscribe = true;\r\n            if (this.count === 0) {\r\n                _super.prototype.unsubscribe.call(this);\r\n            }\r\n        }\r\n    };\r\n    return GroupBySubscriber;\r\n}(Subscriber));\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(GroupDurationSubscriber, _super);\r\n    function GroupDurationSubscriber(key, group, parent) {\r\n        _super.call(this, group);\r\n        this.key = key;\r\n        this.group = group;\r\n        this.parent = parent;\r\n    }\r\n    GroupDurationSubscriber.prototype._next = function (value) {\r\n        this.complete();\r\n    };\r\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\r\n        var _a = this, parent = _a.parent, key = _a.key;\r\n        this.key = this.parent = null;\r\n        if (parent) {\r\n            parent.removeGroup(key);\r\n        }\r\n    };\r\n    return GroupDurationSubscriber;\r\n}(Subscriber));\r\n/**\r\n * An Observable representing values belonging to the same group represented by\r\n * a common key. The values emitted by a GroupedObservable come from the source\r\n * Observable. The common key is available as the field `key` on a\r\n * GroupedObservable instance.\r\n *\r\n * @class GroupedObservable<K, T>\r\n */\r\nexport var GroupedObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(GroupedObservable, _super);\r\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\r\n        _super.call(this);\r\n        this.key = key;\r\n        this.groupSubject = groupSubject;\r\n        this.refCountSubscription = refCountSubscription;\r\n    }\r\n    GroupedObservable.prototype._subscribe = function (subscriber) {\r\n        var subscription = new Subscription();\r\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\r\n        if (refCountSubscription && !refCountSubscription.closed) {\r\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\r\n        }\r\n        subscription.add(groupSubject.subscribe(subscriber));\r\n        return subscription;\r\n    };\r\n    return GroupedObservable;\r\n}(Observable));\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {\r\n    __extends(InnerRefCountSubscription, _super);\r\n    function InnerRefCountSubscription(parent) {\r\n        _super.call(this);\r\n        this.parent = parent;\r\n        parent.count++;\r\n    }\r\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\r\n        var parent = this.parent;\r\n        if (!parent.closed && !this.closed) {\r\n            _super.prototype.unsubscribe.call(this);\r\n            parent.count -= 1;\r\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\r\n                parent.unsubscribe();\r\n            }\r\n        }\r\n    };\r\n    return InnerRefCountSubscription;\r\n}(Subscription));\r\n//# sourceMappingURL=groupBy.js.map \r\n",null]}