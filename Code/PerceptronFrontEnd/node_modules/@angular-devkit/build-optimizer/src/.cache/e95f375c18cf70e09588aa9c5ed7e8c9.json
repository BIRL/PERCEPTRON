{"remainingRequest":"D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\observable\\BoundCallbackObservable.js","dependencies":[{"path":"D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\observable\\BoundCallbackObservable.js","mtime":1532940287248},{"path":"D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Observable } from '../Observable';\r\nimport { tryCatch } from '../util/tryCatch';\r\nimport { errorObject } from '../util/errorObject';\r\nimport { AsyncSubject } from '../AsyncSubject';\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport var BoundCallbackObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(BoundCallbackObservable, _super);\r\n    function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\r\n        _super.call(this);\r\n        this.callbackFunc = callbackFunc;\r\n        this.selector = selector;\r\n        this.args = args;\r\n        this.context = context;\r\n        this.scheduler = scheduler;\r\n    }\r\n    /* tslint:enable:max-line-length */\r\n    /**\r\n     * Converts a callback API to a function that returns an Observable.\r\n     *\r\n     * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\r\n     * it will return a function `g` that when called as `g(x)` will output an\r\n     * Observable.</span>\r\n     *\r\n     * `bindCallback` is not an operator because its input and output are not\r\n     * Observables. The input is a function `func` with some parameters, but the\r\n     * last parameter must be a callback function that `func` calls when it is\r\n     * done.\r\n     *\r\n     * The output of `bindCallback` is a function that takes the same parameters\r\n     * as `func`, except the last one (the callback). When the output function\r\n     * is called with arguments, it will return an Observable. If `func` function\r\n     * calls its callback with one argument, the Observable will emit that value.\r\n     * If on the other hand callback is called with multiple values, resulting\r\n     * Observable will emit an array with these arguments.\r\n     *\r\n     * It is very important to remember, that input function `func` is not called\r\n     * when output function is, but rather when Observable returned by output\r\n     * function is subscribed. This means if `func` makes AJAX request, that request\r\n     * will be made every time someone subscribes to resulting Observable, but not before.\r\n     *\r\n     * Optionally, selector function can be passed to `bindObservable`. That function\r\n     * takes the same arguments as callback, and returns value\r\n     * that will be emitted by Observable instead of callback parameters themselves.\r\n     * Even though by default multiple arguments passed to callback appear in the stream as array,\r\n     * selector function will be called with arguments directly, just as callback would.\r\n     * This means you can imagine default selector (when one is not provided explicitly)\r\n     * as function that aggregates all its arguments into array, or simply returns first argument,\r\n     * if there is only one.\r\n     *\r\n     * Last optional parameter - {@link Scheduler} - can be used to control when call\r\n     * to `func` happens after someone subscribes to Observable, as well as when results\r\n     * passed to callback will be emitted. By default subscription to Observable calls `func`\r\n     * synchronously, but using `Scheduler.async` as last parameter will defer call to input function,\r\n     * just like wrapping that call in `setTimeout` with time `0` would. So if you use async Scheduler\r\n     * and call `subscribe` on output Observable, all function calls that are currently executing,\r\n     * will end before `func` is invoked.\r\n     *\r\n     * When it comes to emitting results passed to callback, by default they are emitted\r\n     * immediately after `func` invokes callback. In particular, if callback is called synchronously,\r\n     * then subscription to resulting Observable will call `next` function synchronously as well.\r\n     * If you want to defer that call, using `Scheduler.async` will, again, do the job.\r\n     * This means that by using `Scheduler.async` you can, in a sense, ensure that `func`\r\n     * always calls its callback asynchronously, thus avoiding terrifying Zalgo.\r\n     *\r\n     * Note that Observable created by output function will always emit only one value\r\n     * and then complete right after. Even if `func` calls callback multiple times, values from\r\n     * second and following calls will never appear in the stream. If you need to\r\n     * listen for multiple calls, you probably want to use {@link fromEvent} or\r\n     * {@link fromEventPattern} instead.\r\n     *\r\n     * If `func` depends on some context (`this` property), that context will be set\r\n     * to the same context that output function has at call time. In particular, if `func`\r\n     * is called as method of some object, in order to preserve proper behaviour,\r\n     * it is recommended to set context of output function to that object as well,\r\n     * provided `func` is not already bound.\r\n     *\r\n     * If input function calls its callback in \"node style\" (i.e. first argument to callback is\r\n     * optional error parameter signaling whether call failed or not), {@link bindNodeCallback}\r\n     * provides convenient error handling and probably is a better choice.\r\n     * `bindCallback` will treat such functions without any difference and error parameter\r\n     * (whether passed or not) will always be interpreted as regular callback argument.\r\n     *\r\n     *\r\n     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\r\n     * // Suppose we have jQuery.getJSON('/my/url', callback)\r\n     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\r\n     * var result = getJSONAsObservable('/my/url');\r\n     * result.subscribe(x => console.log(x), e => console.error(e));\r\n     *\r\n     *\r\n     * @example <caption>Receive array of arguments passed to callback</caption>\r\n     * someFunction((a, b, c) => {\r\n     *   console.log(a); // 5\r\n     *   console.log(b); // 'some string'\r\n     *   console.log(c); // {someProperty: 'someValue'}\r\n     * });\r\n     *\r\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\r\n     * boundSomeFunction().subscribe(values => {\r\n     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\r\n     * });\r\n     *\r\n     *\r\n     * @example <caption>Use bindCallback with selector function</caption>\r\n     * someFunction((a, b, c) => {\r\n     *   console.log(a); // 'a'\r\n     *   console.log(b); // 'b'\r\n     *   console.log(c); // 'c'\r\n     * });\r\n     *\r\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\r\n     * boundSomeFunction().subscribe(value => {\r\n     *   console.log(value) // 'abc'\r\n     * });\r\n     *\r\n     *\r\n     * @example <caption>Compare behaviour with and without async Scheduler</caption>\r\n     * function iCallMyCallbackSynchronously(cb) {\r\n     *   cb();\r\n     * }\r\n     *\r\n     * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\r\n     * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\r\n     *\r\n     * boundSyncFn().subscribe(() => console.log('I was sync!'));\r\n     * boundAsyncFn().subscribe(() => console.log('I was async!'));\r\n     * console.log('This happened...');\r\n     *\r\n     * // Logs:\r\n     * // I was sync!\r\n     * // This happened...\r\n     * // I was async!\r\n     *\r\n     *\r\n     * @example <caption>Use bindCallback on object method</caption>\r\n     * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\r\n     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\r\n     * .subscribe(subscriber);\r\n     *\r\n     *\r\n     * @see {@link bindNodeCallback}\r\n     * @see {@link from}\r\n     * @see {@link fromPromise}\r\n     *\r\n     * @param {function} func Function with a callback as the last parameter.\r\n     * @param {function} [selector] A function which takes the arguments from the\r\n     * callback and maps those to a value to emit on the output Observable.\r\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\r\n     * callbacks.\r\n     * @return {function(...params: *): Observable} A function which returns the\r\n     * Observable that delivers the same values the callback would deliver.\r\n     * @static true\r\n     * @name bindCallback\r\n     * @owner Observable\r\n     */\r\n    BoundCallbackObservable.create = function (func, selector, scheduler) {\r\n        if (selector === void 0) {\r\n            selector = undefined;\r\n        }\r\n        return function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i - 0] = arguments[_i];\r\n            }\r\n            return new BoundCallbackObservable(func, selector, args, this, scheduler);\r\n        };\r\n    };\r\n    BoundCallbackObservable.prototype._subscribe = function (subscriber) {\r\n        var callbackFunc = this.callbackFunc;\r\n        var args = this.args;\r\n        var scheduler = this.scheduler;\r\n        var subject = this.subject;\r\n        if (!scheduler) {\r\n            if (!subject) {\r\n                subject = this.subject = new AsyncSubject();\r\n                var handler = function handlerFn() {\r\n                    var innerArgs = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        innerArgs[_i - 0] = arguments[_i];\r\n                    }\r\n                    var source = handlerFn.source;\r\n                    var selector = source.selector, subject = source.subject;\r\n                    if (selector) {\r\n                        var result_1 = tryCatch(selector).apply(this, innerArgs);\r\n                        if (result_1 === errorObject) {\r\n                            subject.error(errorObject.e);\r\n                        }\r\n                        else {\r\n                            subject.next(result_1);\r\n                            subject.complete();\r\n                        }\r\n                    }\r\n                    else {\r\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\r\n                        subject.complete();\r\n                    }\r\n                };\r\n                // use named function instance to avoid closure.\r\n                handler.source = this;\r\n                var result = tryCatch(callbackFunc).apply(this.context, args.concat(handler));\r\n                if (result === errorObject) {\r\n                    subject.error(errorObject.e);\r\n                }\r\n            }\r\n            return subject.subscribe(subscriber);\r\n        }\r\n        else {\r\n            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\r\n        }\r\n    };\r\n    BoundCallbackObservable.dispatch = function (state) {\r\n        var self = this;\r\n        var source = state.source, subscriber = state.subscriber, context = state.context;\r\n        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;\r\n        var subject = source.subject;\r\n        if (!subject) {\r\n            subject = source.subject = new AsyncSubject();\r\n            var handler = function handlerFn() {\r\n                var innerArgs = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    innerArgs[_i - 0] = arguments[_i];\r\n                }\r\n                var source = handlerFn.source;\r\n                var selector = source.selector, subject = source.subject;\r\n                if (selector) {\r\n                    var result_2 = tryCatch(selector).apply(this, innerArgs);\r\n                    if (result_2 === errorObject) {\r\n                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject.e, subject: subject }));\r\n                    }\r\n                    else {\r\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\r\n                    }\r\n                }\r\n                else {\r\n                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\r\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\r\n                }\r\n            };\r\n            // use named function to pass values in without closure\r\n            handler.source = source;\r\n            var result = tryCatch(callbackFunc).apply(context, args.concat(handler));\r\n            if (result === errorObject) {\r\n                subject.error(errorObject.e);\r\n            }\r\n        }\r\n        self.add(subject.subscribe(subscriber));\r\n    };\r\n    return BoundCallbackObservable;\r\n}(Observable));\r\nfunction dispatchNext(arg) {\r\n    var value = arg.value, subject = arg.subject;\r\n    subject.next(value);\r\n    subject.complete();\r\n}\r\nfunction dispatchError(arg) {\r\n    var err = arg.err, subject = arg.subject;\r\n    subject.error(err);\r\n}\r\n//# sourceMappingURL=BoundCallbackObservable.js.map \r\n",null]}