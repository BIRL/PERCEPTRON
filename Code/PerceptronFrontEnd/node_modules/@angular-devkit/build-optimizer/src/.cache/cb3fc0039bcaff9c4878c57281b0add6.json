{"remainingRequest":"E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\observable\\IntervalObservable.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\observable\\IntervalObservable.js","mtime":1532940287248},{"path":"E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { isNumeric } from '../util/isNumeric';\r\nimport { Observable } from '../Observable';\r\nimport { async } from '../scheduler/async';\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport var IntervalObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(IntervalObservable, _super);\r\n    function IntervalObservable(period, scheduler) {\r\n        if (period === void 0) {\r\n            period = 0;\r\n        }\r\n        if (scheduler === void 0) {\r\n            scheduler = async;\r\n        }\r\n        _super.call(this);\r\n        this.period = period;\r\n        this.scheduler = scheduler;\r\n        if (!isNumeric(period) || period < 0) {\r\n            this.period = 0;\r\n        }\r\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\r\n            this.scheduler = async;\r\n        }\r\n    }\r\n    /**\r\n     * Creates an Observable that emits sequential numbers every specified\r\n     * interval of time, on a specified IScheduler.\r\n     *\r\n     * <span class=\"informal\">Emits incremental numbers periodically in time.\r\n     * </span>\r\n     *\r\n     * <img src=\"./img/interval.png\" width=\"100%\">\r\n     *\r\n     * `interval` returns an Observable that emits an infinite sequence of\r\n     * ascending integers, with a constant interval of time of your choosing\r\n     * between those emissions. The first emission is not sent immediately, but\r\n     * only after the first period has passed. By default, this operator uses the\r\n     * `async` IScheduler to provide a notion of time, but you may pass any\r\n     * IScheduler to it.\r\n     *\r\n     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\r\n     * var numbers = Rx.Observable.interval(1000);\r\n     * numbers.subscribe(x => console.log(x));\r\n     *\r\n     * @see {@link timer}\r\n     * @see {@link delay}\r\n     *\r\n     * @param {number} [period=0] The interval size in milliseconds (by default)\r\n     * or the time unit determined by the scheduler's clock.\r\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\r\n     * the emission of values, and providing a notion of \"time\".\r\n     * @return {Observable} An Observable that emits a sequential number each time\r\n     * interval.\r\n     * @static true\r\n     * @name interval\r\n     * @owner Observable\r\n     */\r\n    IntervalObservable.create = function (period, scheduler) {\r\n        if (period === void 0) {\r\n            period = 0;\r\n        }\r\n        if (scheduler === void 0) {\r\n            scheduler = async;\r\n        }\r\n        return new IntervalObservable(period, scheduler);\r\n    };\r\n    IntervalObservable.dispatch = function (state) {\r\n        var index = state.index, subscriber = state.subscriber, period = state.period;\r\n        subscriber.next(index);\r\n        if (subscriber.closed) {\r\n            return;\r\n        }\r\n        state.index += 1;\r\n        this.schedule(state, period);\r\n    };\r\n    IntervalObservable.prototype._subscribe = function (subscriber) {\r\n        var index = 0;\r\n        var period = this.period;\r\n        var scheduler = this.scheduler;\r\n        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\r\n            index: index, subscriber: subscriber, period: period\r\n        }));\r\n    };\r\n    return IntervalObservable;\r\n}(Observable));\r\n//# sourceMappingURL=IntervalObservable.js.map \r\n",null]}