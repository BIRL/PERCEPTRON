{"remainingRequest":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\observable\\GenerateObservable.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\observable\\GenerateObservable.js","mtime":1532940287248},{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Observable } from '../Observable';\r\nimport { isScheduler } from '../util/isScheduler';\r\nvar selfSelector = function (value) { return value; };\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport var GenerateObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(GenerateObservable, _super);\r\n    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {\r\n        _super.call(this);\r\n        this.initialState = initialState;\r\n        this.condition = condition;\r\n        this.iterate = iterate;\r\n        this.resultSelector = resultSelector;\r\n        this.scheduler = scheduler;\r\n    }\r\n    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\r\n        if (arguments.length == 1) {\r\n            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);\r\n        }\r\n        if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\r\n            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);\r\n        }\r\n        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);\r\n    };\r\n    GenerateObservable.prototype._subscribe = function (subscriber) {\r\n        var state = this.initialState;\r\n        if (this.scheduler) {\r\n            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {\r\n                subscriber: subscriber,\r\n                iterate: this.iterate,\r\n                condition: this.condition,\r\n                resultSelector: this.resultSelector,\r\n                state: state\r\n            });\r\n        }\r\n        var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;\r\n        do {\r\n            if (condition) {\r\n                var conditionResult = void 0;\r\n                try {\r\n                    conditionResult = condition(state);\r\n                }\r\n                catch (err) {\r\n                    subscriber.error(err);\r\n                    return;\r\n                }\r\n                if (!conditionResult) {\r\n                    subscriber.complete();\r\n                    break;\r\n                }\r\n            }\r\n            var value = void 0;\r\n            try {\r\n                value = resultSelector(state);\r\n            }\r\n            catch (err) {\r\n                subscriber.error(err);\r\n                return;\r\n            }\r\n            subscriber.next(value);\r\n            if (subscriber.closed) {\r\n                break;\r\n            }\r\n            try {\r\n                state = iterate(state);\r\n            }\r\n            catch (err) {\r\n                subscriber.error(err);\r\n                return;\r\n            }\r\n        } while (true);\r\n    };\r\n    GenerateObservable.dispatch = function (state) {\r\n        var subscriber = state.subscriber, condition = state.condition;\r\n        if (subscriber.closed) {\r\n            return;\r\n        }\r\n        if (state.needIterate) {\r\n            try {\r\n                state.state = state.iterate(state.state);\r\n            }\r\n            catch (err) {\r\n                subscriber.error(err);\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            state.needIterate = true;\r\n        }\r\n        if (condition) {\r\n            var conditionResult = void 0;\r\n            try {\r\n                conditionResult = condition(state.state);\r\n            }\r\n            catch (err) {\r\n                subscriber.error(err);\r\n                return;\r\n            }\r\n            if (!conditionResult) {\r\n                subscriber.complete();\r\n                return;\r\n            }\r\n            if (subscriber.closed) {\r\n                return;\r\n            }\r\n        }\r\n        var value;\r\n        try {\r\n            value = state.resultSelector(state.state);\r\n        }\r\n        catch (err) {\r\n            subscriber.error(err);\r\n            return;\r\n        }\r\n        if (subscriber.closed) {\r\n            return;\r\n        }\r\n        subscriber.next(value);\r\n        if (subscriber.closed) {\r\n            return;\r\n        }\r\n        return this.schedule(state);\r\n    };\r\n    return GenerateObservable;\r\n}(Observable));\r\n//# sourceMappingURL=GenerateObservable.js.map \r\n",null]}