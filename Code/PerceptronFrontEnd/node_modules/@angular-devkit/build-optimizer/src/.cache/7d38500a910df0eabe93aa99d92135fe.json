{"remainingRequest":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operator\\multicast.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operator\\multicast.js","mtime":1532940287326},{"path":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START .._operators_multicast PURE_IMPORTS_END */\r\nimport { multicast as higherOrder } from '../operators/multicast';\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Allows source Observable to be subscribed only once with a Subject of choice,\r\n * while still sharing its values between multiple subscribers.\r\n *\r\n * <span class=\"informal\">Subscribe to Observable once, but send its values to multiple subscribers.</span>\r\n *\r\n * <img src=\"./img/multicast.png\" width=\"100%\">\r\n *\r\n * `multicast` is an operator that works in two modes.\r\n *\r\n * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject\r\n * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be\r\n * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that\r\n * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when\r\n * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription\r\n * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,\r\n * even though usually it would send a request per every subscriber. Since it sends a request at the moment of\r\n * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.\r\n *\r\n * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,\r\n * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source\r\n * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,\r\n * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count\r\n * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least\r\n * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a\r\n * ConnectableObservable, use `refCount`.\r\n *\r\n * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.\r\n * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable\r\n * as well, which should be the input stream modified by any operators you want. Note that in this\r\n * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If\r\n * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.\r\n * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,\r\n * if inside the selector function you subscribe to the input Observable multiple times, actual source stream\r\n * will be subscribed only once. So if you have a chain of operators that use some Observable many times,\r\n * but you want to subscribe to that Observable only once, this is the mode you would use.\r\n *\r\n * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the\r\n * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject\r\n * has some special properties, Observable returned by `multicast` will have them as well. If you want to use\r\n * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},\r\n * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},\r\n * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually\r\n * just wrappers around `multicast`, with a specific Subject hardcoded inside.\r\n *\r\n * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,\r\n * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.\r\n *\r\n * @example <caption>Use ConnectableObservable</caption>\r\n * const seconds = Rx.Observable.interval(1000);\r\n * const connectableSeconds = seconds.multicast(new Subject());\r\n *\r\n * connectableSeconds.subscribe(value => console.log('first: ' + value));\r\n * connectableSeconds.subscribe(value => console.log('second: ' + value));\r\n *\r\n * // At this point still nothing happens, even though we subscribed twice.\r\n *\r\n * connectableSeconds.connect();\r\n *\r\n * // From now on `seconds` are being logged to the console,\r\n * // twice per every second. `seconds` Observable was however only subscribed once,\r\n * // so under the hood Observable.interval had only one clock started.\r\n *\r\n * @example <caption>Use selector</caption>\r\n * const seconds = Rx.Observable.interval(1000);\r\n *\r\n * seconds\r\n *     .multicast(\r\n *         () => new Subject(),\r\n *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.\r\n *                                         // Because we are inside selector, `seconds` is subscribed once,\r\n *     )                                   // thus starting only one clock used internally by Observable.interval.\r\n *     .subscribe();\r\n *\r\n * @see {@link publish}\r\n * @see {@link publishLast}\r\n * @see {@link publishBehavior}\r\n * @see {@link publishReplay}\r\n * @see {@link share}\r\n * @see {@link shareReplay}\r\n *\r\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through\r\n * which the source sequence's elements will be multicast to the selector function input Observable or\r\n * ConnectableObservable returned by the operator.\r\n * @param {Function} [selector] - Optional selector function that can use the input stream\r\n * as many times as needed, without causing multiple subscriptions to the source stream.\r\n * Subscribers to the input source will receive all notifications of the source from the\r\n * time of the subscription forward.\r\n * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector\r\n * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.\r\n *\r\n * @method multicast\r\n * @owner Observable\r\n */\r\nexport function multicast(subjectOrSubjectFactory, selector) {\r\n    return higherOrder(subjectOrSubjectFactory, selector)(this);\r\n}\r\n//# sourceMappingURL=multicast.js.map \r\n",null]}