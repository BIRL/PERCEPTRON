{"remainingRequest":"D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\bufferWhen.js","dependencies":[{"path":"D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\bufferWhen.js","mtime":1532940287357},{"path":"D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"D:\\01_PERCEPTRON\\01_PERCEPTRON_FROM_98\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Subscription } from '../Subscription';\r\nimport { tryCatch } from '../util/tryCatch';\r\nimport { errorObject } from '../util/errorObject';\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\n/**\r\n * Buffers the source Observable values, using a factory function of closing\r\n * Observables to determine when to close, emit, and reset the buffer.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array. When it\r\n * starts collecting values, it calls a function that returns an Observable that\r\n * tells when to close the buffer and restart collecting.</span>\r\n *\r\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\r\n *\r\n * Opens a buffer immediately, then closes the buffer when the observable\r\n * returned by calling `closingSelector` function emits a value. When it closes\r\n * the buffer, it immediately opens a new buffer and repeats the process.\r\n *\r\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferWhen(() =>\r\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\r\n * );\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n * @see {@link bufferTime}\r\n * @see {@link bufferToggle}\r\n * @see {@link windowWhen}\r\n *\r\n * @param {function(): Observable} closingSelector A function that takes no\r\n * arguments and returns an Observable that signals buffer closure.\r\n * @return {Observable<T[]>} An observable of arrays of buffered values.\r\n * @method bufferWhen\r\n * @owner Observable\r\n */\r\nexport function bufferWhen(closingSelector) {\r\n    return function (source) {\r\n        return source.lift(new BufferWhenOperator(closingSelector));\r\n    };\r\n}\r\nvar BufferWhenOperator = /*@__PURE__*/ (function () {\r\n    function BufferWhenOperator(closingSelector) {\r\n        this.closingSelector = closingSelector;\r\n    }\r\n    BufferWhenOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\r\n    };\r\n    return BufferWhenOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(BufferWhenSubscriber, _super);\r\n    function BufferWhenSubscriber(destination, closingSelector) {\r\n        _super.call(this, destination);\r\n        this.closingSelector = closingSelector;\r\n        this.subscribing = false;\r\n        this.openBuffer();\r\n    }\r\n    BufferWhenSubscriber.prototype._next = function (value) {\r\n        this.buffer.push(value);\r\n    };\r\n    BufferWhenSubscriber.prototype._complete = function () {\r\n        var buffer = this.buffer;\r\n        if (buffer) {\r\n            this.destination.next(buffer);\r\n        }\r\n        _super.prototype._complete.call(this);\r\n    };\r\n    BufferWhenSubscriber.prototype._unsubscribe = function () {\r\n        this.buffer = null;\r\n        this.subscribing = false;\r\n    };\r\n    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.openBuffer();\r\n    };\r\n    BufferWhenSubscriber.prototype.notifyComplete = function () {\r\n        if (this.subscribing) {\r\n            this.complete();\r\n        }\r\n        else {\r\n            this.openBuffer();\r\n        }\r\n    };\r\n    BufferWhenSubscriber.prototype.openBuffer = function () {\r\n        var closingSubscription = this.closingSubscription;\r\n        if (closingSubscription) {\r\n            this.remove(closingSubscription);\r\n            closingSubscription.unsubscribe();\r\n        }\r\n        var buffer = this.buffer;\r\n        if (this.buffer) {\r\n            this.destination.next(buffer);\r\n        }\r\n        this.buffer = [];\r\n        var closingNotifier = tryCatch(this.closingSelector)();\r\n        if (closingNotifier === errorObject) {\r\n            this.error(errorObject.e);\r\n        }\r\n        else {\r\n            closingSubscription = new Subscription();\r\n            this.closingSubscription = closingSubscription;\r\n            this.add(closingSubscription);\r\n            this.subscribing = true;\r\n            closingSubscription.add(subscribeToResult(this, closingNotifier));\r\n            this.subscribing = false;\r\n        }\r\n    };\r\n    return BufferWhenSubscriber;\r\n}(OuterSubscriber));\r\n//# sourceMappingURL=bufferWhen.js.map \r\n",null]}