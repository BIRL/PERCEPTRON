{"remainingRequest":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\distinct.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\distinct.js","mtime":1532940287373},{"path":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\nimport { Set } from '../util/Set';\r\n/**\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\r\n *\r\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\r\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\r\n * source observable directly with an equality check against previous values.\r\n *\r\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\r\n *\r\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\r\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\r\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\r\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\r\n *\r\n * @example <caption>A simple example with numbers</caption>\r\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\r\n *   .distinct()\r\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\r\n *\r\n * @example <caption>An example using a keySelector function</caption>\r\n * interface Person {\r\n *    age: number,\r\n *    name: string\r\n * }\r\n *\r\n * Observable.of<Person>(\r\n *     { age: 4, name: 'Foo'},\r\n *     { age: 7, name: 'Bar'},\r\n *     { age: 5, name: 'Foo'})\r\n *     .distinct((p: Person) => p.name)\r\n *     .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo' }\r\n * // { age: 7, name: 'Bar' }\r\n *\r\n * @see {@link distinctUntilChanged}\r\n * @see {@link distinctUntilKeyChanged}\r\n *\r\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\r\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\r\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\r\n * @method distinct\r\n * @owner Observable\r\n */\r\nexport function distinct(keySelector, flushes) {\r\n    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };\r\n}\r\nvar DistinctOperator = /*@__PURE__*/ (function () {\r\n    function DistinctOperator(keySelector, flushes) {\r\n        this.keySelector = keySelector;\r\n        this.flushes = flushes;\r\n    }\r\n    DistinctOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\r\n    };\r\n    return DistinctOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport var DistinctSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(DistinctSubscriber, _super);\r\n    function DistinctSubscriber(destination, keySelector, flushes) {\r\n        _super.call(this, destination);\r\n        this.keySelector = keySelector;\r\n        this.values = new Set();\r\n        if (flushes) {\r\n            this.add(subscribeToResult(this, flushes));\r\n        }\r\n    }\r\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.values.clear();\r\n    };\r\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\r\n        this._error(error);\r\n    };\r\n    DistinctSubscriber.prototype._next = function (value) {\r\n        if (this.keySelector) {\r\n            this._useKeySelector(value);\r\n        }\r\n        else {\r\n            this._finalizeNext(value, value);\r\n        }\r\n    };\r\n    DistinctSubscriber.prototype._useKeySelector = function (value) {\r\n        var key;\r\n        var destination = this.destination;\r\n        try {\r\n            key = this.keySelector(value);\r\n        }\r\n        catch (err) {\r\n            destination.error(err);\r\n            return;\r\n        }\r\n        this._finalizeNext(key, value);\r\n    };\r\n    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\r\n        var values = this.values;\r\n        if (!values.has(key)) {\r\n            values.add(key);\r\n            this.destination.next(value);\r\n        }\r\n    };\r\n    return DistinctSubscriber;\r\n}(OuterSubscriber));\r\n//# sourceMappingURL=distinct.js.map \r\n",null]}