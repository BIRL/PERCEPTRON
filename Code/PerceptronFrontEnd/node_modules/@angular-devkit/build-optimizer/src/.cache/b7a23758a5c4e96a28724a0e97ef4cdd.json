{"remainingRequest":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\withLatestFrom.js","dependencies":[{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\withLatestFrom.js","mtime":1532940287445},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Combines the source Observable with other Observables to create an Observable\r\n * whose values are calculated from the latest values of each, only when the\r\n * source emits.\r\n *\r\n * <span class=\"informal\">Whenever the source Observable emits a value, it\r\n * computes a formula using that value plus the latest values from other input\r\n * Observables, then emits the output of that formula.</span>\r\n *\r\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\r\n *\r\n * `withLatestFrom` combines each value from the source Observable (the\r\n * instance) with the latest values from the other input Observables only when\r\n * the source emits a value, optionally using a `project` function to determine\r\n * the value to be emitted on the output Observable. All input Observables must\r\n * emit at least one value before the output Observable will emit a value.\r\n *\r\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var timer = Rx.Observable.interval(1000);\r\n * var result = clicks.withLatestFrom(timer);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link combineLatest}\r\n *\r\n * @param {ObservableInput} other An input Observable to combine with the source\r\n * Observable. More than one input Observables may be given as argument.\r\n * @param {Function} [project] Projection function for combining values\r\n * together. Receives all values in order of the Observables passed, where the\r\n * first parameter is a value from the source Observable. (e.g.\r\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\r\n * passed, arrays will be emitted on the output Observable.\r\n * @return {Observable} An Observable of projected values from the most recent\r\n * values from each input Observable, or an array of the most recent values from\r\n * each input Observable.\r\n * @method withLatestFrom\r\n * @owner Observable\r\n */\r\nexport function withLatestFrom() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i - 0] = arguments[_i];\r\n    }\r\n    return function (source) {\r\n        var project;\r\n        if (typeof args[args.length - 1] === 'function') {\r\n            project = args.pop();\r\n        }\r\n        var observables = args;\r\n        return source.lift(new WithLatestFromOperator(observables, project));\r\n    };\r\n}\r\nvar WithLatestFromOperator = /*@__PURE__*/ (function () {\r\n    function WithLatestFromOperator(observables, project) {\r\n        this.observables = observables;\r\n        this.project = project;\r\n    }\r\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\r\n    };\r\n    return WithLatestFromOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(WithLatestFromSubscriber, _super);\r\n    function WithLatestFromSubscriber(destination, observables, project) {\r\n        _super.call(this, destination);\r\n        this.observables = observables;\r\n        this.project = project;\r\n        this.toRespond = [];\r\n        var len = observables.length;\r\n        this.values = new Array(len);\r\n        for (var i = 0; i < len; i++) {\r\n            this.toRespond.push(i);\r\n        }\r\n        for (var i = 0; i < len; i++) {\r\n            var observable = observables[i];\r\n            this.add(subscribeToResult(this, observable, observable, i));\r\n        }\r\n    }\r\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.values[outerIndex] = innerValue;\r\n        var toRespond = this.toRespond;\r\n        if (toRespond.length > 0) {\r\n            var found = toRespond.indexOf(outerIndex);\r\n            if (found !== -1) {\r\n                toRespond.splice(found, 1);\r\n            }\r\n        }\r\n    };\r\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\r\n        // noop\r\n    };\r\n    WithLatestFromSubscriber.prototype._next = function (value) {\r\n        if (this.toRespond.length === 0) {\r\n            var args = [value].concat(this.values);\r\n            if (this.project) {\r\n                this._tryProject(args);\r\n            }\r\n            else {\r\n                this.destination.next(args);\r\n            }\r\n        }\r\n    };\r\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\r\n        var result;\r\n        try {\r\n            result = this.project.apply(this, args);\r\n        }\r\n        catch (err) {\r\n            this.destination.error(err);\r\n            return;\r\n        }\r\n        this.destination.next(result);\r\n    };\r\n    return WithLatestFromSubscriber;\r\n}(OuterSubscriber));\r\n//# sourceMappingURL=withLatestFrom.js.map \r\n",null]}