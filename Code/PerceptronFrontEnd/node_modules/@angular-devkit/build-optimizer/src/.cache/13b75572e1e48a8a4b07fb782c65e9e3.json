{"remainingRequest":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\zip.js","dependencies":[{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\zip.js","mtime":1532940287445},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { ArrayObservable } from '../observable/ArrayObservable';\r\nimport { isArray } from '../util/isArray';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * @param observables\r\n * @return {Observable<R>}\r\n * @method zip\r\n * @owner Observable\r\n */\r\nexport function zip() {\r\n    var observables = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        observables[_i - 0] = arguments[_i];\r\n    }\r\n    return function zipOperatorFunction(source) {\r\n        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\r\n    };\r\n}\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\r\n * of its input Observables.\r\n *\r\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\r\n * Otherwise, an array of the input values is returned.\r\n *\r\n * @example <caption>Combine age and name from different sources</caption>\r\n *\r\n * let age$ = Observable.of<number>(27, 25, 29);\r\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\r\n * let isDev$ = Observable.of<boolean>(true, true, false);\r\n *\r\n * Observable\r\n *     .zip(age$,\r\n *          name$,\r\n *          isDev$,\r\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\r\n *     .subscribe(x => console.log(x));\r\n *\r\n * // outputs\r\n * // { age: 27, name: 'Foo', isDev: true }\r\n * // { age: 25, name: 'Bar', isDev: true }\r\n * // { age: 29, name: 'Beer', isDev: false }\r\n *\r\n * @param observables\r\n * @return {Observable<R>}\r\n * @static true\r\n * @name zip\r\n * @owner Observable\r\n */\r\nexport function zipStatic() {\r\n    var observables = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        observables[_i - 0] = arguments[_i];\r\n    }\r\n    var project = observables[observables.length - 1];\r\n    if (typeof project === 'function') {\r\n        observables.pop();\r\n    }\r\n    return new ArrayObservable(observables).lift(new ZipOperator(project));\r\n}\r\nexport var ZipOperator = /*@__PURE__*/ (function () {\r\n    function ZipOperator(project) {\r\n        this.project = project;\r\n    }\r\n    ZipOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new ZipSubscriber(subscriber, this.project));\r\n    };\r\n    return ZipOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport var ZipSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(ZipSubscriber, _super);\r\n    function ZipSubscriber(destination, project, values) {\r\n        if (values === void 0) {\r\n            values = Object.create(null);\r\n        }\r\n        _super.call(this, destination);\r\n        this.iterators = [];\r\n        this.active = 0;\r\n        this.project = (typeof project === 'function') ? project : null;\r\n        this.values = values;\r\n    }\r\n    ZipSubscriber.prototype._next = function (value) {\r\n        var iterators = this.iterators;\r\n        if (isArray(value)) {\r\n            iterators.push(new StaticArrayIterator(value));\r\n        }\r\n        else if (typeof value[Symbol_iterator] === 'function') {\r\n            iterators.push(new StaticIterator(value[Symbol_iterator]()));\r\n        }\r\n        else {\r\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\r\n        }\r\n    };\r\n    ZipSubscriber.prototype._complete = function () {\r\n        var iterators = this.iterators;\r\n        var len = iterators.length;\r\n        if (len === 0) {\r\n            this.destination.complete();\r\n            return;\r\n        }\r\n        this.active = len;\r\n        for (var i = 0; i < len; i++) {\r\n            var iterator = iterators[i];\r\n            if (iterator.stillUnsubscribed) {\r\n                this.add(iterator.subscribe(iterator, i));\r\n            }\r\n            else {\r\n                this.active--; // not an observable\r\n            }\r\n        }\r\n    };\r\n    ZipSubscriber.prototype.notifyInactive = function () {\r\n        this.active--;\r\n        if (this.active === 0) {\r\n            this.destination.complete();\r\n        }\r\n    };\r\n    ZipSubscriber.prototype.checkIterators = function () {\r\n        var iterators = this.iterators;\r\n        var len = iterators.length;\r\n        var destination = this.destination;\r\n        // abort if not all of them have values\r\n        for (var i = 0; i < len; i++) {\r\n            var iterator = iterators[i];\r\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\r\n                return;\r\n            }\r\n        }\r\n        var shouldComplete = false;\r\n        var args = [];\r\n        for (var i = 0; i < len; i++) {\r\n            var iterator = iterators[i];\r\n            var result = iterator.next();\r\n            // check to see if it's completed now that you've gotten\r\n            // the next value.\r\n            if (iterator.hasCompleted()) {\r\n                shouldComplete = true;\r\n            }\r\n            if (result.done) {\r\n                destination.complete();\r\n                return;\r\n            }\r\n            args.push(result.value);\r\n        }\r\n        if (this.project) {\r\n            this._tryProject(args);\r\n        }\r\n        else {\r\n            destination.next(args);\r\n        }\r\n        if (shouldComplete) {\r\n            destination.complete();\r\n        }\r\n    };\r\n    ZipSubscriber.prototype._tryProject = function (args) {\r\n        var result;\r\n        try {\r\n            result = this.project.apply(this, args);\r\n        }\r\n        catch (err) {\r\n            this.destination.error(err);\r\n            return;\r\n        }\r\n        this.destination.next(result);\r\n    };\r\n    return ZipSubscriber;\r\n}(Subscriber));\r\nvar StaticIterator = /*@__PURE__*/ (function () {\r\n    function StaticIterator(iterator) {\r\n        this.iterator = iterator;\r\n        this.nextResult = iterator.next();\r\n    }\r\n    StaticIterator.prototype.hasValue = function () {\r\n        return true;\r\n    };\r\n    StaticIterator.prototype.next = function () {\r\n        var result = this.nextResult;\r\n        this.nextResult = this.iterator.next();\r\n        return result;\r\n    };\r\n    StaticIterator.prototype.hasCompleted = function () {\r\n        var nextResult = this.nextResult;\r\n        return nextResult && nextResult.done;\r\n    };\r\n    return StaticIterator;\r\n}());\r\nvar StaticArrayIterator = /*@__PURE__*/ (function () {\r\n    function StaticArrayIterator(array) {\r\n        this.array = array;\r\n        this.index = 0;\r\n        this.length = 0;\r\n        this.length = array.length;\r\n    }\r\n    StaticArrayIterator.prototype[Symbol_iterator] = function () {\r\n        return this;\r\n    };\r\n    StaticArrayIterator.prototype.next = function (value) {\r\n        var i = this.index++;\r\n        var array = this.array;\r\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\r\n    };\r\n    StaticArrayIterator.prototype.hasValue = function () {\r\n        return this.array.length > this.index;\r\n    };\r\n    StaticArrayIterator.prototype.hasCompleted = function () {\r\n        return this.array.length === this.index;\r\n    };\r\n    return StaticArrayIterator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar ZipBufferIterator = /*@__PURE__*/ (function (_super) {\r\n    __extends(ZipBufferIterator, _super);\r\n    function ZipBufferIterator(destination, parent, observable) {\r\n        _super.call(this, destination);\r\n        this.parent = parent;\r\n        this.observable = observable;\r\n        this.stillUnsubscribed = true;\r\n        this.buffer = [];\r\n        this.isComplete = false;\r\n    }\r\n    ZipBufferIterator.prototype[Symbol_iterator] = function () {\r\n        return this;\r\n    };\r\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\r\n    //    this is legit because `next()` will never be called by a subscription in this case.\r\n    ZipBufferIterator.prototype.next = function () {\r\n        var buffer = this.buffer;\r\n        if (buffer.length === 0 && this.isComplete) {\r\n            return { value: null, done: true };\r\n        }\r\n        else {\r\n            return { value: buffer.shift(), done: false };\r\n        }\r\n    };\r\n    ZipBufferIterator.prototype.hasValue = function () {\r\n        return this.buffer.length > 0;\r\n    };\r\n    ZipBufferIterator.prototype.hasCompleted = function () {\r\n        return this.buffer.length === 0 && this.isComplete;\r\n    };\r\n    ZipBufferIterator.prototype.notifyComplete = function () {\r\n        if (this.buffer.length > 0) {\r\n            this.isComplete = true;\r\n            this.parent.notifyInactive();\r\n        }\r\n        else {\r\n            this.destination.complete();\r\n        }\r\n    };\r\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.buffer.push(innerValue);\r\n        this.parent.checkIterators();\r\n    };\r\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\r\n        return subscribeToResult(this, this.observable, this, index);\r\n    };\r\n    return ZipBufferIterator;\r\n}(OuterSubscriber));\r\n//# sourceMappingURL=zip.js.map \r\n",null]}