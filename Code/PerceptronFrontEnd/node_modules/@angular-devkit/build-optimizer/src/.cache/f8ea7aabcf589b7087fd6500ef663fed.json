{"remainingRequest":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\scheduler\\VirtualTimeScheduler.js","dependencies":[{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\scheduler\\VirtualTimeScheduler.js","mtime":1532940287451},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { AsyncAction } from './AsyncAction';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nexport var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {\r\n    __extends(VirtualTimeScheduler, _super);\r\n    function VirtualTimeScheduler(SchedulerAction, maxFrames) {\r\n        var _this = this;\r\n        if (SchedulerAction === void 0) {\r\n            SchedulerAction = VirtualAction;\r\n        }\r\n        if (maxFrames === void 0) {\r\n            maxFrames = Number.POSITIVE_INFINITY;\r\n        }\r\n        _super.call(this, SchedulerAction, function () { return _this.frame; });\r\n        this.maxFrames = maxFrames;\r\n        this.frame = 0;\r\n        this.index = -1;\r\n    }\r\n    /**\r\n     * Prompt the Scheduler to execute all of its queued actions, therefore\r\n     * clearing its queue.\r\n     * @return {void}\r\n     */\r\n    VirtualTimeScheduler.prototype.flush = function () {\r\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\r\n        var error, action;\r\n        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\r\n            if (error = action.execute(action.state, action.delay)) {\r\n                break;\r\n            }\r\n        }\r\n        if (error) {\r\n            while (action = actions.shift()) {\r\n                action.unsubscribe();\r\n            }\r\n            throw error;\r\n        }\r\n    };\r\n    VirtualTimeScheduler.frameTimeFactor = 10;\r\n    return VirtualTimeScheduler;\r\n}(AsyncScheduler));\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport var VirtualAction = /*@__PURE__*/ (function (_super) {\r\n    __extends(VirtualAction, _super);\r\n    function VirtualAction(scheduler, work, index) {\r\n        if (index === void 0) {\r\n            index = scheduler.index += 1;\r\n        }\r\n        _super.call(this, scheduler, work);\r\n        this.scheduler = scheduler;\r\n        this.work = work;\r\n        this.index = index;\r\n        this.active = true;\r\n        this.index = scheduler.index = index;\r\n    }\r\n    VirtualAction.prototype.schedule = function (state, delay) {\r\n        if (delay === void 0) {\r\n            delay = 0;\r\n        }\r\n        if (!this.id) {\r\n            return _super.prototype.schedule.call(this, state, delay);\r\n        }\r\n        this.active = false;\r\n        // If an action is rescheduled, we save allocations by mutating its state,\r\n        // pushing it to the end of the scheduler queue, and recycling the action.\r\n        // But since the VirtualTimeScheduler is used for testing, VirtualActions\r\n        // must be immutable so they can be inspected later.\r\n        var action = new VirtualAction(this.scheduler, this.work);\r\n        this.add(action);\r\n        return action.schedule(state, delay);\r\n    };\r\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\r\n        if (delay === void 0) {\r\n            delay = 0;\r\n        }\r\n        this.delay = scheduler.frame + delay;\r\n        var actions = scheduler.actions;\r\n        actions.push(this);\r\n        actions.sort(VirtualAction.sortActions);\r\n        return true;\r\n    };\r\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\r\n        if (delay === void 0) {\r\n            delay = 0;\r\n        }\r\n        return undefined;\r\n    };\r\n    VirtualAction.prototype._execute = function (state, delay) {\r\n        if (this.active === true) {\r\n            return _super.prototype._execute.call(this, state, delay);\r\n        }\r\n    };\r\n    VirtualAction.sortActions = function (a, b) {\r\n        if (a.delay === b.delay) {\r\n            if (a.index === b.index) {\r\n                return 0;\r\n            }\r\n            else if (a.index > b.index) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        else if (a.delay > b.delay) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    };\r\n    return VirtualAction;\r\n}(AsyncAction));\r\n//# sourceMappingURL=VirtualTimeScheduler.js.map \r\n",null]}