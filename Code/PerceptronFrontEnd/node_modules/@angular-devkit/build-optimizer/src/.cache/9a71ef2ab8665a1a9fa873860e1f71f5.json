{"remainingRequest":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\scheduler\\AnimationFrameAction.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\scheduler\\AnimationFrameAction.js","mtime":1532940287448},{"path":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\Deployment\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { AsyncAction } from './AsyncAction';\r\nimport { AnimationFrame } from '../util/AnimationFrame';\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport var AnimationFrameAction = /*@__PURE__*/ (function (_super) {\r\n    __extends(AnimationFrameAction, _super);\r\n    function AnimationFrameAction(scheduler, work) {\r\n        _super.call(this, scheduler, work);\r\n        this.scheduler = scheduler;\r\n        this.work = work;\r\n    }\r\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\r\n        if (delay === void 0) {\r\n            delay = 0;\r\n        }\r\n        // If delay is greater than 0, request as an async action.\r\n        if (delay !== null && delay > 0) {\r\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\r\n        }\r\n        // Push the action to the end of the scheduler queue.\r\n        scheduler.actions.push(this);\r\n        // If an animation frame has already been requested, don't request another\r\n        // one. If an animation frame hasn't been requested yet, request one. Return\r\n        // the current animation frame request id.\r\n        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));\r\n    };\r\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\r\n        if (delay === void 0) {\r\n            delay = 0;\r\n        }\r\n        // If delay exists and is greater than 0, or if the delay is null (the\r\n        // action wasn't rescheduled) but was originally scheduled as an async\r\n        // action, then recycle as an async action.\r\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\r\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\r\n        }\r\n        // If the scheduler queue is empty, cancel the requested animation frame and\r\n        // set the scheduled flag to undefined so the next AnimationFrameAction will\r\n        // request its own.\r\n        if (scheduler.actions.length === 0) {\r\n            AnimationFrame.cancelAnimationFrame(id);\r\n            scheduler.scheduled = undefined;\r\n        }\r\n        // Return undefined so the action knows to request a new async id if it's rescheduled.\r\n        return undefined;\r\n    };\r\n    return AnimationFrameAction;\r\n}(AsyncAction));\r\n//# sourceMappingURL=AnimationFrameAction.js.map \r\n",null]}