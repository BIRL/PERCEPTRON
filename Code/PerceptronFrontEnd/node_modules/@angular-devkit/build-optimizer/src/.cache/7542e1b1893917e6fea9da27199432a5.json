{"remainingRequest":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operator\\bufferCount.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operator\\bufferCount.js","mtime":1532940287279},{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START .._operators_bufferCount PURE_IMPORTS_END */\r\nimport { bufferCount as higherOrder } from '../operators/bufferCount';\r\n/**\r\n * Buffers the source Observable values until the size hits the maximum\r\n * `bufferSize` given.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array, and emits\r\n * that array only when its size reaches `bufferSize`.</span>\r\n *\r\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\r\n *\r\n * Buffers a number of values from the source Observable by `bufferSize` then\r\n * emits the buffer and clears it, and starts a new buffer each\r\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\r\n * `null`, then new buffers are started immediately at the start of the source\r\n * and when each buffer closes and is emitted.\r\n *\r\n * @example <caption>Emit the last two click events as an array</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferCount(2);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @example <caption>On every click, emit the last two click events as an array</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferCount(2, 1);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferTime}\r\n * @see {@link bufferToggle}\r\n * @see {@link bufferWhen}\r\n * @see {@link pairwise}\r\n * @see {@link windowCount}\r\n *\r\n * @param {number} bufferSize The maximum size of the buffer emitted.\r\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\r\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\r\n * on every other value from the source. A new buffer is started at the\r\n * beginning of the source by default.\r\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\r\n * @method bufferCount\r\n * @owner Observable\r\n */\r\nexport function bufferCount(bufferSize, startBufferEvery) {\r\n    if (startBufferEvery === void 0) {\r\n        startBufferEvery = null;\r\n    }\r\n    return higherOrder(bufferSize, startBufferEvery)(this);\r\n}\r\n//# sourceMappingURL=bufferCount.js.map \r\n",null]}