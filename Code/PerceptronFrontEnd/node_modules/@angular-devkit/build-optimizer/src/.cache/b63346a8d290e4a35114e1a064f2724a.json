{"remainingRequest":"D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operator\\bufferWhen.js","dependencies":[{"path":"D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operator\\bufferWhen.js","mtime":1577085432359},{"path":"D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1577085403617},{"path":"D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1577085366146}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START .._operators_bufferWhen PURE_IMPORTS_END */\r\nimport { bufferWhen as higherOrder } from '../operators/bufferWhen';\r\n/**\r\n * Buffers the source Observable values, using a factory function of closing\r\n * Observables to determine when to close, emit, and reset the buffer.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array. When it\r\n * starts collecting values, it calls a function that returns an Observable that\r\n * tells when to close the buffer and restart collecting.</span>\r\n *\r\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\r\n *\r\n * Opens a buffer immediately, then closes the buffer when the observable\r\n * returned by calling `closingSelector` function emits a value. When it closes\r\n * the buffer, it immediately opens a new buffer and repeats the process.\r\n *\r\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferWhen(() =>\r\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\r\n * );\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n * @see {@link bufferTime}\r\n * @see {@link bufferToggle}\r\n * @see {@link windowWhen}\r\n *\r\n * @param {function(): Observable} closingSelector A function that takes no\r\n * arguments and returns an Observable that signals buffer closure.\r\n * @return {Observable<T[]>} An observable of arrays of buffered values.\r\n * @method bufferWhen\r\n * @owner Observable\r\n */\r\nexport function bufferWhen(closingSelector) {\r\n    return higherOrder(closingSelector)(this);\r\n}\r\n//# sourceMappingURL=bufferWhen.js.map \r\n",null]}