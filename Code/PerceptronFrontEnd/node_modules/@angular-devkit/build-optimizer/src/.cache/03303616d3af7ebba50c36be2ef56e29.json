{"remainingRequest":"D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\delayWhen.js","dependencies":[{"path":"D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\delayWhen.js","mtime":1577085432492},{"path":"D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1577085403617},{"path":"D:\\01_PERCEPTRON\\gitHub\\PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1577085366146}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\n/**\r\n * Delays the emission of items from the source Observable by a given time span\r\n * determined by the emissions of another Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\r\n * delay duration is determined by a second Observable.</span>\r\n *\r\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\r\n *\r\n * `delayWhen` time shifts each emitted value from the source Observable by a\r\n * time span determined by another Observable. When the source emits a value,\r\n * the `delayDurationSelector` function is called with the source value as\r\n * argument, and should return an Observable, called the \"duration\" Observable.\r\n * The source value is emitted on the output Observable only when the duration\r\n * Observable emits a value or completes.\r\n *\r\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\r\n * is an Observable. When `subscriptionDelay` emits its first value or\r\n * completes, the source Observable is subscribed to and starts behaving like\r\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\r\n * `delayWhen` will subscribe to the source Observable as soon as the output\r\n * Observable is subscribed.\r\n *\r\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var delayedClicks = clicks.delayWhen(event =>\r\n *   Rx.Observable.interval(Math.random() * 5000)\r\n * );\r\n * delayedClicks.subscribe(x => console.log(x));\r\n *\r\n * @see {@link debounce}\r\n * @see {@link delay}\r\n *\r\n * @param {function(value: T): Observable} delayDurationSelector A function that\r\n * returns an Observable for each value emitted by the source Observable, which\r\n * is then used to delay the emission of that item on the output Observable\r\n * until the Observable returned from this function emits a value.\r\n * @param {Observable} subscriptionDelay An Observable that triggers the\r\n * subscription to the source Observable once it emits any value.\r\n * @return {Observable} An Observable that delays the emissions of the source\r\n * Observable by an amount of time specified by the Observable returned by\r\n * `delayDurationSelector`.\r\n * @method delayWhen\r\n * @owner Observable\r\n */\r\nexport function delayWhen(delayDurationSelector, subscriptionDelay) {\r\n    if (subscriptionDelay) {\r\n        return function (source) {\r\n            return new SubscriptionDelayObservable(source, subscriptionDelay)\r\n                .lift(new DelayWhenOperator(delayDurationSelector));\r\n        };\r\n    }\r\n    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };\r\n}\r\nvar DelayWhenOperator = /*@__PURE__*/ (function () {\r\n    function DelayWhenOperator(delayDurationSelector) {\r\n        this.delayDurationSelector = delayDurationSelector;\r\n    }\r\n    DelayWhenOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\r\n    };\r\n    return DelayWhenOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(DelayWhenSubscriber, _super);\r\n    function DelayWhenSubscriber(destination, delayDurationSelector) {\r\n        _super.call(this, destination);\r\n        this.delayDurationSelector = delayDurationSelector;\r\n        this.completed = false;\r\n        this.delayNotifierSubscriptions = [];\r\n        this.values = [];\r\n    }\r\n    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.destination.next(outerValue);\r\n        this.removeSubscription(innerSub);\r\n        this.tryComplete();\r\n    };\r\n    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\r\n        this._error(error);\r\n    };\r\n    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\r\n        var value = this.removeSubscription(innerSub);\r\n        if (value) {\r\n            this.destination.next(value);\r\n        }\r\n        this.tryComplete();\r\n    };\r\n    DelayWhenSubscriber.prototype._next = function (value) {\r\n        try {\r\n            var delayNotifier = this.delayDurationSelector(value);\r\n            if (delayNotifier) {\r\n                this.tryDelay(delayNotifier, value);\r\n            }\r\n        }\r\n        catch (err) {\r\n            this.destination.error(err);\r\n        }\r\n    };\r\n    DelayWhenSubscriber.prototype._complete = function () {\r\n        this.completed = true;\r\n        this.tryComplete();\r\n    };\r\n    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\r\n        subscription.unsubscribe();\r\n        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\r\n        var value = null;\r\n        if (subscriptionIdx !== -1) {\r\n            value = this.values[subscriptionIdx];\r\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\r\n            this.values.splice(subscriptionIdx, 1);\r\n        }\r\n        return value;\r\n    };\r\n    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\r\n        var notifierSubscription = subscribeToResult(this, delayNotifier, value);\r\n        if (notifierSubscription && !notifierSubscription.closed) {\r\n            this.add(notifierSubscription);\r\n            this.delayNotifierSubscriptions.push(notifierSubscription);\r\n        }\r\n        this.values.push(value);\r\n    };\r\n    DelayWhenSubscriber.prototype.tryComplete = function () {\r\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\r\n            this.destination.complete();\r\n        }\r\n    };\r\n    return DelayWhenSubscriber;\r\n}(OuterSubscriber));\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(SubscriptionDelayObservable, _super);\r\n    function SubscriptionDelayObservable(source, subscriptionDelay) {\r\n        _super.call(this);\r\n        this.source = source;\r\n        this.subscriptionDelay = subscriptionDelay;\r\n    }\r\n    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\r\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\r\n    };\r\n    return SubscriptionDelayObservable;\r\n}(Observable));\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(SubscriptionDelaySubscriber, _super);\r\n    function SubscriptionDelaySubscriber(parent, source) {\r\n        _super.call(this);\r\n        this.parent = parent;\r\n        this.source = source;\r\n        this.sourceSubscribed = false;\r\n    }\r\n    SubscriptionDelaySubscriber.prototype._next = function (unused) {\r\n        this.subscribeToSource();\r\n    };\r\n    SubscriptionDelaySubscriber.prototype._error = function (err) {\r\n        this.unsubscribe();\r\n        this.parent.error(err);\r\n    };\r\n    SubscriptionDelaySubscriber.prototype._complete = function () {\r\n        this.subscribeToSource();\r\n    };\r\n    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\r\n        if (!this.sourceSubscribed) {\r\n            this.sourceSubscribed = true;\r\n            this.unsubscribe();\r\n            this.source.subscribe(this.parent);\r\n        }\r\n    };\r\n    return SubscriptionDelaySubscriber;\r\n}(Subscriber));\r\n//# sourceMappingURL=delayWhen.js.map \r\n",null]}