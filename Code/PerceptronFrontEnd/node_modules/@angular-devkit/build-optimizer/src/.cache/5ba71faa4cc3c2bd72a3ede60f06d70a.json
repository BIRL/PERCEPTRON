{"remainingRequest":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\timeoutWith.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\timeoutWith.js","mtime":1532940287439},{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { async } from '../scheduler/async';\r\nimport { isDate } from '../util/isDate';\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\n/* tslint:enable:max-line-length */\r\n/**\r\n *\r\n * Errors if Observable does not emit a value in given time span, in case of which\r\n * subscribes to the second Observable.\r\n *\r\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\r\n *\r\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\r\n *\r\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\r\n * still accepting as a first argument either a number or a Date, which control - respectively -\r\n * when values of source Observable should be emitted or when it should complete.\r\n *\r\n * The only difference is that it accepts a second, required parameter. This parameter\r\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\r\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\r\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\r\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\r\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\r\n * stream completes, it completes as well.\r\n *\r\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\r\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\r\n * as a consequence - when second Observable will be subscribed, since subscription happens\r\n * immediately after failing check.\r\n *\r\n * @example <caption>Add fallback observable</caption>\r\n * const seconds = Rx.Observable.interval(1000);\r\n * const minutes = Rx.Observable.interval(60 * 1000);\r\n *\r\n * seconds.timeoutWith(900, minutes)\r\n *     .subscribe(\r\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\r\n *                                      // since first value of `seconds` will not arrive fast enough.\r\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\r\n *                                 // but here will never be called.\r\n *     );\r\n *\r\n * @param {number|Date} due Number specifying period within which Observable must emit values\r\n *                          or Date specifying before when Observable should complete\r\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\r\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\r\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\r\n *                          passed as a second parameter.\r\n * @method timeoutWith\r\n * @owner Observable\r\n */\r\nexport function timeoutWith(due, withObservable, scheduler) {\r\n    if (scheduler === void 0) {\r\n        scheduler = async;\r\n    }\r\n    return function (source) {\r\n        var absoluteTimeout = isDate(due);\r\n        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\r\n        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\r\n    };\r\n}\r\nvar TimeoutWithOperator = /*@__PURE__*/ (function () {\r\n    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\r\n        this.waitFor = waitFor;\r\n        this.absoluteTimeout = absoluteTimeout;\r\n        this.withObservable = withObservable;\r\n        this.scheduler = scheduler;\r\n    }\r\n    TimeoutWithOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\r\n    };\r\n    return TimeoutWithOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(TimeoutWithSubscriber, _super);\r\n    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\r\n        _super.call(this, destination);\r\n        this.absoluteTimeout = absoluteTimeout;\r\n        this.waitFor = waitFor;\r\n        this.withObservable = withObservable;\r\n        this.scheduler = scheduler;\r\n        this.action = null;\r\n        this.scheduleTimeout();\r\n    }\r\n    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\r\n        var withObservable = subscriber.withObservable;\r\n        subscriber._unsubscribeAndRecycle();\r\n        subscriber.add(subscribeToResult(subscriber, withObservable));\r\n    };\r\n    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\r\n        var action = this.action;\r\n        if (action) {\r\n            // Recycle the action if we've already scheduled one. All the production\r\n            // Scheduler Actions mutate their state/delay time and return themeselves.\r\n            // VirtualActions are immutable, so they create and return a clone. In this\r\n            // case, we need to set the action reference to the most recent VirtualAction,\r\n            // to ensure that's the one we clone from next time.\r\n            this.action = action.schedule(this, this.waitFor);\r\n        }\r\n        else {\r\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\r\n        }\r\n    };\r\n    TimeoutWithSubscriber.prototype._next = function (value) {\r\n        if (!this.absoluteTimeout) {\r\n            this.scheduleTimeout();\r\n        }\r\n        _super.prototype._next.call(this, value);\r\n    };\r\n    TimeoutWithSubscriber.prototype._unsubscribe = function () {\r\n        this.action = null;\r\n        this.scheduler = null;\r\n        this.withObservable = null;\r\n    };\r\n    return TimeoutWithSubscriber;\r\n}(OuterSubscriber));\r\n//# sourceMappingURL=timeoutWith.js.map \r\n",null]}