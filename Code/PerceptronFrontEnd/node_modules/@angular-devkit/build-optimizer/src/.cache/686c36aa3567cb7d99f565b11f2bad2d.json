{"remainingRequest":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\windowWhen.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\windowWhen.js","mtime":1532940287444},{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\~Code\\PERCEPTRON_v1.0.0.0\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Subject } from '../Subject';\r\nimport { tryCatch } from '../util/tryCatch';\r\nimport { errorObject } from '../util/errorObject';\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\n/**\r\n * Branch out the source Observable values as a nested Observable using a\r\n * factory function of closing Observables to determine when to start a new\r\n * window.\r\n *\r\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\r\n * Observable instead of an array.</span>\r\n *\r\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable emits connected, non-overlapping windows.\r\n * It emits the current window and opens a new one whenever the Observable\r\n * produced by the specified `closingSelector` function emits an item. The first\r\n * window is opened immediately when subscribing to the output Observable.\r\n *\r\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks\r\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\r\n *   .map(win => win.take(2)) // each window has at most 2 emissions\r\n *   .mergeAll(); // flatten the Observable-of-Observables\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link window}\r\n * @see {@link windowCount}\r\n * @see {@link windowTime}\r\n * @see {@link windowToggle}\r\n * @see {@link bufferWhen}\r\n *\r\n * @param {function(): Observable} closingSelector A function that takes no\r\n * arguments and returns an Observable that signals (on either `next` or\r\n * `complete`) when to close the previous window and start a new one.\r\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\r\n * are Observables.\r\n * @method windowWhen\r\n * @owner Observable\r\n */\r\nexport function windowWhen(closingSelector) {\r\n    return function windowWhenOperatorFunction(source) {\r\n        return source.lift(new WindowOperator(closingSelector));\r\n    };\r\n}\r\nvar WindowOperator = /*@__PURE__*/ (function () {\r\n    function WindowOperator(closingSelector) {\r\n        this.closingSelector = closingSelector;\r\n    }\r\n    WindowOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\r\n    };\r\n    return WindowOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar WindowSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(WindowSubscriber, _super);\r\n    function WindowSubscriber(destination, closingSelector) {\r\n        _super.call(this, destination);\r\n        this.destination = destination;\r\n        this.closingSelector = closingSelector;\r\n        this.openWindow();\r\n    }\r\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.openWindow(innerSub);\r\n    };\r\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\r\n        this._error(error);\r\n    };\r\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\r\n        this.openWindow(innerSub);\r\n    };\r\n    WindowSubscriber.prototype._next = function (value) {\r\n        this.window.next(value);\r\n    };\r\n    WindowSubscriber.prototype._error = function (err) {\r\n        this.window.error(err);\r\n        this.destination.error(err);\r\n        this.unsubscribeClosingNotification();\r\n    };\r\n    WindowSubscriber.prototype._complete = function () {\r\n        this.window.complete();\r\n        this.destination.complete();\r\n        this.unsubscribeClosingNotification();\r\n    };\r\n    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\r\n        if (this.closingNotification) {\r\n            this.closingNotification.unsubscribe();\r\n        }\r\n    };\r\n    WindowSubscriber.prototype.openWindow = function (innerSub) {\r\n        if (innerSub === void 0) {\r\n            innerSub = null;\r\n        }\r\n        if (innerSub) {\r\n            this.remove(innerSub);\r\n            innerSub.unsubscribe();\r\n        }\r\n        var prevWindow = this.window;\r\n        if (prevWindow) {\r\n            prevWindow.complete();\r\n        }\r\n        var window = this.window = new Subject();\r\n        this.destination.next(window);\r\n        var closingNotifier = tryCatch(this.closingSelector)();\r\n        if (closingNotifier === errorObject) {\r\n            var err = errorObject.e;\r\n            this.destination.error(err);\r\n            this.window.error(err);\r\n        }\r\n        else {\r\n            this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\r\n        }\r\n    };\r\n    return WindowSubscriber;\r\n}(OuterSubscriber));\r\n//# sourceMappingURL=windowWhen.js.map \r\n",null]}