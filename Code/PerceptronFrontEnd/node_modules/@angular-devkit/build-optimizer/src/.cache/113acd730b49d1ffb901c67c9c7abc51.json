{"remainingRequest":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\observable\\RangeObservable.js","dependencies":[{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\observable\\RangeObservable.js","mtime":1532940287264},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"D:\\~Code\\Perceptron\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Observable } from '../Observable';\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport var RangeObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(RangeObservable, _super);\r\n    function RangeObservable(start, count, scheduler) {\r\n        _super.call(this);\r\n        this.start = start;\r\n        this._count = count;\r\n        this.scheduler = scheduler;\r\n    }\r\n    /**\r\n     * Creates an Observable that emits a sequence of numbers within a specified\r\n     * range.\r\n     *\r\n     * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\r\n     *\r\n     * <img src=\"./img/range.png\" width=\"100%\">\r\n     *\r\n     * `range` operator emits a range of sequential integers, in order, where you\r\n     * select the `start` of the range and its `length`. By default, uses no\r\n     * IScheduler and just delivers the notifications synchronously, but may use\r\n     * an optional IScheduler to regulate those deliveries.\r\n     *\r\n     * @example <caption>Emits the numbers 1 to 10</caption>\r\n     * var numbers = Rx.Observable.range(1, 10);\r\n     * numbers.subscribe(x => console.log(x));\r\n     *\r\n     * @see {@link timer}\r\n     * @see {@link interval}\r\n     *\r\n     * @param {number} [start=0] The value of the first integer in the sequence.\r\n     * @param {number} [count=0] The number of sequential integers to generate.\r\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\r\n     * the emissions of the notifications.\r\n     * @return {Observable} An Observable of numbers that emits a finite range of\r\n     * sequential integers.\r\n     * @static true\r\n     * @name range\r\n     * @owner Observable\r\n     */\r\n    RangeObservable.create = function (start, count, scheduler) {\r\n        if (start === void 0) {\r\n            start = 0;\r\n        }\r\n        if (count === void 0) {\r\n            count = 0;\r\n        }\r\n        return new RangeObservable(start, count, scheduler);\r\n    };\r\n    RangeObservable.dispatch = function (state) {\r\n        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\r\n        if (index >= count) {\r\n            subscriber.complete();\r\n            return;\r\n        }\r\n        subscriber.next(start);\r\n        if (subscriber.closed) {\r\n            return;\r\n        }\r\n        state.index = index + 1;\r\n        state.start = start + 1;\r\n        this.schedule(state);\r\n    };\r\n    RangeObservable.prototype._subscribe = function (subscriber) {\r\n        var index = 0;\r\n        var start = this.start;\r\n        var count = this._count;\r\n        var scheduler = this.scheduler;\r\n        if (scheduler) {\r\n            return scheduler.schedule(RangeObservable.dispatch, 0, {\r\n                index: index, count: count, start: start, subscriber: subscriber\r\n            });\r\n        }\r\n        else {\r\n            do {\r\n                if (index++ >= count) {\r\n                    subscriber.complete();\r\n                    break;\r\n                }\r\n                subscriber.next(start++);\r\n                if (subscriber.closed) {\r\n                    break;\r\n                }\r\n            } while (true);\r\n        }\r\n    };\r\n    return RangeObservable;\r\n}(Observable));\r\n//# sourceMappingURL=RangeObservable.js.map \r\n",null]}