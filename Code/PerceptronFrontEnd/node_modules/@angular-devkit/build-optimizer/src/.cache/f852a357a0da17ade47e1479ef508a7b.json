{"remainingRequest":"E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\skipLast.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\skipLast.js","mtime":1532940287426},{"path":"E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Subscriber } from '../Subscriber';\r\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\r\n/**\r\n * Skip the last `count` values emitted by the source Observable.\r\n *\r\n * <img src=\"./img/skipLast.png\" width=\"100%\">\r\n *\r\n * `skipLast` returns an Observable that accumulates a queue with a length\r\n * enough to store the first `count` values. As more values are received,\r\n * values are taken from the front of the queue and produced on the result\r\n * sequence. This causes values to be delayed.\r\n *\r\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\r\n * var many = Rx.Observable.range(1, 5);\r\n * var skipLastTwo = many.skipLast(2);\r\n * skipLastTwo.subscribe(x => console.log(x));\r\n *\r\n * // Results in:\r\n * // 1 2 3\r\n *\r\n * @see {@link skip}\r\n * @see {@link skipUntil}\r\n * @see {@link skipWhile}\r\n * @see {@link take}\r\n *\r\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\r\n * ArgumentOutOrRangeError if `i < 0`.\r\n *\r\n * @param {number} count Number of elements to skip from the end of the source Observable.\r\n * @returns {Observable<T>} An Observable that skips the last count values\r\n * emitted by the source Observable.\r\n * @method skipLast\r\n * @owner Observable\r\n */\r\nexport function skipLast(count) {\r\n    return function (source) { return source.lift(new SkipLastOperator(count)); };\r\n}\r\nvar SkipLastOperator = /*@__PURE__*/ (function () {\r\n    function SkipLastOperator(_skipCount) {\r\n        this._skipCount = _skipCount;\r\n        if (this._skipCount < 0) {\r\n            throw new ArgumentOutOfRangeError;\r\n        }\r\n    }\r\n    SkipLastOperator.prototype.call = function (subscriber, source) {\r\n        if (this._skipCount === 0) {\r\n            // If we don't want to skip any values then just subscribe\r\n            // to Subscriber without any further logic.\r\n            return source.subscribe(new Subscriber(subscriber));\r\n        }\r\n        else {\r\n            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\r\n        }\r\n    };\r\n    return SkipLastOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar SkipLastSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(SkipLastSubscriber, _super);\r\n    function SkipLastSubscriber(destination, _skipCount) {\r\n        _super.call(this, destination);\r\n        this._skipCount = _skipCount;\r\n        this._count = 0;\r\n        this._ring = new Array(_skipCount);\r\n    }\r\n    SkipLastSubscriber.prototype._next = function (value) {\r\n        var skipCount = this._skipCount;\r\n        var count = this._count++;\r\n        if (count < skipCount) {\r\n            this._ring[count] = value;\r\n        }\r\n        else {\r\n            var currentIndex = count % skipCount;\r\n            var ring = this._ring;\r\n            var oldValue = ring[currentIndex];\r\n            ring[currentIndex] = value;\r\n            this.destination.next(oldValue);\r\n        }\r\n    };\r\n    return SkipLastSubscriber;\r\n}(Subscriber));\r\n//# sourceMappingURL=skipLast.js.map \r\n",null]}