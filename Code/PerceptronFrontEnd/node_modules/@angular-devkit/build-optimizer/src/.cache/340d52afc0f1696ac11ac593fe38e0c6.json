{"remainingRequest":"E:\\01_PERCEPTRON\\GitHub\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!E:\\01_PERCEPTRON\\GitHub\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\sample.js","dependencies":[{"path":"E:\\01_PERCEPTRON\\GitHub\\Code\\PerceptronFrontEnd\\node_modules\\rxjs\\_esm5\\operators\\sample.js","mtime":1532940287420},{"path":"E:\\01_PERCEPTRON\\GitHub\\Code\\PerceptronFrontEnd\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532940271448},{"path":"E:\\01_PERCEPTRON\\GitHub\\Code\\PerceptronFrontEnd\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532940256149}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { OuterSubscriber } from '../OuterSubscriber';\r\nimport { subscribeToResult } from '../util/subscribeToResult';\r\n/**\r\n * Emits the most recently emitted value from the source Observable whenever\r\n * another Observable, the `notifier`, emits.\r\n *\r\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\r\n * the `notifier` Observable emits something.</span>\r\n *\r\n * <img src=\"./img/sample.png\" width=\"100%\">\r\n *\r\n * Whenever the `notifier` Observable emits a value or completes, `sample`\r\n * looks at the source Observable and emits whichever value it has most recently\r\n * emitted since the previous sampling, unless the source has not emitted\r\n * anything since the previous sampling. The `notifier` is subscribed to as soon\r\n * as the output Observable is subscribed.\r\n *\r\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\r\n * var seconds = Rx.Observable.interval(1000);\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = seconds.sample(clicks);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link audit}\r\n * @see {@link debounce}\r\n * @see {@link sampleTime}\r\n * @see {@link throttle}\r\n *\r\n * @param {Observable<any>} notifier The Observable to use for sampling the\r\n * source Observable.\r\n * @return {Observable<T>} An Observable that emits the results of sampling the\r\n * values emitted by the source Observable whenever the notifier Observable\r\n * emits value or completes.\r\n * @method sample\r\n * @owner Observable\r\n */\r\nexport function sample(notifier) {\r\n    return function (source) { return source.lift(new SampleOperator(notifier)); };\r\n}\r\nvar SampleOperator = /*@__PURE__*/ (function () {\r\n    function SampleOperator(notifier) {\r\n        this.notifier = notifier;\r\n    }\r\n    SampleOperator.prototype.call = function (subscriber, source) {\r\n        var sampleSubscriber = new SampleSubscriber(subscriber);\r\n        var subscription = source.subscribe(sampleSubscriber);\r\n        subscription.add(subscribeToResult(sampleSubscriber, this.notifier));\r\n        return subscription;\r\n    };\r\n    return SampleOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar SampleSubscriber = /*@__PURE__*/ (function (_super) {\r\n    __extends(SampleSubscriber, _super);\r\n    function SampleSubscriber() {\r\n        _super.apply(this, arguments);\r\n        this.hasValue = false;\r\n    }\r\n    SampleSubscriber.prototype._next = function (value) {\r\n        this.value = value;\r\n        this.hasValue = true;\r\n    };\r\n    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.emitValue();\r\n    };\r\n    SampleSubscriber.prototype.notifyComplete = function () {\r\n        this.emitValue();\r\n    };\r\n    SampleSubscriber.prototype.emitValue = function () {\r\n        if (this.hasValue) {\r\n            this.hasValue = false;\r\n            this.destination.next(this.value);\r\n        }\r\n    };\r\n    return SampleSubscriber;\r\n}(OuterSubscriber));\r\n//# sourceMappingURL=sample.js.map \r\n",null]}